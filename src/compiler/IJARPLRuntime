package runtime;

import compiler.IJARPLParser;
import compiler.IJARPLSymbols;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

public class IJARPLRuntime {

    static HashMap<String,Integer> variables = new HashMap<String,Integer>();
    static Stack<Integer> integerStack = new Stack<Integer>();
    static Stack<Boolean> booleanStack = new Stack<Boolean>();
    static ArrayList<String> programList = new ArrayList<String>();
    static Stack<Integer> nestedStack = new Stack<Integer>();
    static Stack<Boolean> isLoop = new Stack<Boolean>();
    static int iteratorIndex = 0;
    static Stack<Integer> scope = new Stack<Integer>();
    static int scopeCount = 1;

    public static void main(String[] args){
        String fname = "";

        if(fname.contains(".ijarpl")){
            System.out.println("The selected file is not a .ijrpl file");
        }

        if (args.length > 0 ){
            fname = args[0];
        }else {
            System.out.println("Filename should not be empty");
            return;
        }
        try {
            List<String> lines = Files.readAllLines(Path.of(fname));
            for(String line: lines) {
                System.out.println(line);
                programList.add(line);
            }
        } catch (IOException ex) {
            System.out.format("Entered file doesn't exist");
        }

        for( int linecount = 0 ; linecount < programList.size(); linecount++) {
            runTimeExecution();
        }
    }

    static public void throwException(String ex) {
        System.out.println("\n" + ex);
        iteratorIndex = programList.size();
    }

    static public void runTimeExecution(){
        String code = programList.get(iteratorIndex);
        String[] split = code.split(" ");
        int tempNest = 0;
        if (code.contains(IJARPLSymbols.IF_COND.trim()) || code.contains(IJARPLSymbols.ELSE.trim())
                || code.contains(IJARPLSymbols.END_IF_COND.trim()) || code.contains(IJARPLSymbols.FOR_LOOP.trim())
                || code.contains(IJARPLSymbols.END_FOR_LOOP.trim())) {
            split = code.split("_");
            tempNest = Integer.parseInt(split[1]);
            if (code.contains(IJARPLSymbols.IF_COND.trim()) ||code.contains(IJARPLSymbols.FOR_LOOP.trim())) {
                nestedStack.push(tempNest);
            }
        }
        int accm = 0;
        switch(split[0] + " ") {
            case IJARPLSymbols.DECLARATION:
                if (scope.isEmpty()) {
                    if (!variables.containsKey(split[1])) {
                        variables.put(split[1], 0);
                    } else {
                        throwException("Exception variable " + split[1] + " already declared");
                    }
                } else {
                    if (!variables.containsKey(getScope() + split[1])) {
                        variables.put(getScope() + split[1], 0);
                    } else {
                        throwException("Exception variable " + split[1] + " already declared in this scope");
                    }
                }
                break;
            case IJARPLSymbols.ADD :
                accm = integerStack.pop() + integerStack.pop();
                integerStack.push(accm);
                break;
            case IJARPLSymbols.PRINT:
                System.out.println(integerStack.pop());
                break;
            case IJARPLSymbols.ASSIGN :
                if (scope.isEmpty()) {
                    variables.put(split[1], integerStack.pop());
                } else {
                    variables.put(getScope() + split[1], integerStack.pop());
                }
                break;
            case IJARPLSymbols.BOOL:
                booleanStack.push(Boolean.parseBoolean(split[1]));
                break;
            case IJARPLSymbols.DIV:
                accm = integerStack.pop();
                if (accm != 0) {
                    accm = integerStack.pop()/accm;
                    integerStack.push(accm);
                } else {
                    throwException("Exception can't divide number by 0");
                }
                break;
            case IJARPLSymbols.ELSE:
                jumpForward(IJARPLSymbols.END_IF_COND.trim() + "_" + tempNest);
                break;
            case IJARPLSymbols.END_ELSE:
                nestedStack.pop();
                break;
            case IJARPLSymbols.END_IF_COND:
                nestedStack.pop();
                break;
            case IJARPLSymbols.END_FOR_LOOP:
                jumpBackward(IJARPLSymbols.FOR_LOOP.trim() + "_" + nestedStack.pop());
                break;
            case IJARPLSymbols.EQUAL:
                if (integerStack.pop() == integerStack.pop()) {
                    booleanStack.push(true);
                } else {
                    booleanStack.push(false);
                }
                break;
            case IJARPLSymbols.GREATER_THAN:
                accm = integerStack.pop();
                if (integerStack.pop() > accm) {
                    booleanStack.push(true);
                } else {
                    booleanStack.push(false);
                }
                break;
            
            case IJARPLSymbols.END_BLOCK:
                break;    
            case IJARPLSymbols.IF_COND:
                isLoop.push(false);
                break;
            
            case IJARPLSymbols.BLOCK:
                break;
            case IJARPLSymbols.LESS_THAN:
                accm = integerStack.pop();
                if (integerStack.pop() < accm) {
                    booleanStack.push(true);
                } else {
                    booleanStack.push(false);
                }
                break;
            case IJARPLSymbols.EXPR:
                break;    
            case IJARPLSymbols.FOR_LOOP:
                isLoop.push(true);
                break;
            case IJARPLSymbols.MUL:
                integerStack.push((integerStack.pop() * integerStack.pop()));
                break;
            
             case IJARPLSymbols.PROGRAM:
                break;
            case IJARPLSymbols.END_PROGRAM:
                break;
            case IJARPLSymbols.NOT_EQUAL:
                if (integerStack.pop() != integerStack.pop()) {
                    booleanStack.push(true);
                } else {
                    booleanStack.push(false);
                }
                break;
            case IJARPLSymbols.MOD:
                accm = integerStack.pop();
                accm = integerStack.pop() % accm;
                integerStack.push(accm);
                break;
            case IJARPLSymbols.SPACE:
                break;
            case IJARPLSymbols.SUB:
                accm = integerStack.pop();
                accm = integerStack.pop() - accm;
                integerStack.push(accm);
                break;
            case IJARPLSymbols.STATEMENT:
                break;
        }
    }

    public static void jumpForward(String label) {
        boolean ifElse = label.contains(IJARPLSymbols.ELSE.trim())? true : false;
        int id = 0;
        if (ifElse) {
            String[] temp = label.split("_");
            id = Integer.parseInt(temp[1]);
        }
        for (int i = iteratorIndex; i < programList.size(); i++) {
            String code = programList.get(i);
            if (code.trim().equals(label.trim()) || (ifElse && code.trim().contains(IJARPLSymbols.END_IF_COND.trim() + "_" + id))) {
                iteratorIndex = i;
                if (code.trim().contains(IJARPLSymbols.END_IF_COND.trim() + "_" + id)) {
                    nestedStack.pop();
                }
                break;
            }
        }
    }

    public static void jumpBackward(String label) {
        for (int i = iteratorIndex; i >= 0; i--) {
            String code = programList.get(i);
            if (code.equals(label.trim())) {
                iteratorIndex = i-1;
                break;
            }
        }
    }

    public static void jumpToFunction(String label) {
        for (int i = 0; i < programList.size(); i++) {
            String code = programList.get(i);
            if (code.contains(label.trim())) {
                iteratorIndex = i;
                break;
            }
        }
    }

    public static int getScope() {
        int temp = scope.pop();
        scope.push(temp);
        return temp;
    }

}
}
